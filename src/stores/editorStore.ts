import { create } from 'zustand';
import { FileNode, EditorTab } from '../types';

interface EditorStore {
  files: FileNode[];
  openTabs: EditorTab[];
  activeTab: string | null;
  selectedFile: string | null;
  setFiles: (files: FileNode[]) => void;
  openFile: (path: string, name: string, content: string) => void;
  closeTab: (path: string) => void;
  setActiveTab: (path: string) => void;
  updateFileContent: (path: string, content: string) => void;
  createFile: (path: string, name: string, type: 'file' | 'directory') => void;
  deleteFile: (path: string) => void;
  renameFile: (oldPath: string, newPath: string) => void;
  markTabClean: (path: string) => void;
}

const defaultFiles: FileNode[] = [
  {
    name: 'src',
    type: 'directory',
    path: 'src',
    children: [
      {
        name: 'App.jsx',
        type: 'file',
        path: 'src/App.jsx',
        content: `import React from 'react';\n\nfunction App() {\n  return (\n    <div className="app">\n      <h1>Hello World from WebContainer!</h1>\n      <p>Edit src/App.jsx to see changes.</p>\n    </div>\n  );\n}\n\nexport default App;`
      },
      {
        name: 'index.jsx',
        type: 'file',
        path: 'src/index.jsx',
        content: `import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') \n);\n\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);`
      },
      {
        name: 'index.css',
        type: 'file',
        path: 'src/index.css',
        content: `body {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.app {\n  text-align: center;\n  padding: 20px;\n}\n\nh1 {\n  color: #333;\n}`
      }
    ]
  },
  {
    name: 'package.json',
    type: 'file',
    path: 'package.json',
    content: `{
  "name": "webcontainer-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.3",
    "vite": "^4.4.5"
  }
}`
  }, 
  {
    name: 'index.html',
    type: 'file',
    path: 'index.html',
    content: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebContainer App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.jsx"></script>
  </body>
</html>`
  },
//   {
//     name: 'vite.config.js',
//     type: 'file',
//     path: 'vite.config.js',
//     content: `import { defineConfig } from 'vite'
// import react from '@vitejs/plugin-react'

// // https://vitejs.dev/config/
// export default defineConfig({
//   plugins: [react()],
//   server: {
//     port: 3000,
//     host: true // Allow external access
//   }
// })`
//   },

// Update vite.config.js in editorStore
{
  name: 'vite.config.js',
  type: 'file',
  path: 'vite.config.js',
  content: `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    host: true, // Allow external access
    strictPort: true, // Don't try other ports
    hmr: {
      clientPort: 443 // Important for WebContainer HMR
    }
  }
})`
},
  {
    name: '.gitignore',
    type: 'file',
    path: '.gitignore',
    content: `# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.development.local
.env.test.local
.env.production.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox

# DynamoDB Local files
.dynamodb

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# Vite build output
dist
`
  }
];

export const useEditorStore = create<EditorStore>((set, get) => ({
  files: defaultFiles,
  openTabs: [],
  activeTab: null,
  selectedFile: null,

  setFiles: (files) => set({ files }),
  setGeneratedFiles: (files: FileNode[]) => {
    set({ files }); // Replace existing file tree
  },

  openFile: (path, name, content) => {
    const { openTabs } = get();
    const existingTab = openTabs.find(tab => tab.path === path);
    
    if (existingTab) {
      set({ activeTab: path });
      return;
    }

    const newTab: EditorTab = {
      path,
      name,
      content,
      isDirty: false
    };

    set({
      openTabs: [...openTabs, newTab],
      activeTab: path
    });
  },

  closeTab: (path) => {
    const { openTabs, activeTab } = get();
    const newTabs = openTabs.filter(tab => tab.path !== path);
    
    let newActiveTab = activeTab;
    if (activeTab === path) {
      newActiveTab = newTabs.length > 0 ? newTabs[newTabs.length - 1].path : null;
    }

    set({
      openTabs: newTabs,
      activeTab: newActiveTab
    });
  },

  setActiveTab: (path) => set({ activeTab: path }),

  updateFileContent: (path, content) => {
    const { openTabs } = get();
    const updatedTabs = openTabs.map(tab =>
      tab.path === path ? { ...tab, content, isDirty: true } : tab
    );
    
    set({ openTabs: updatedTabs });
  },

  createFile: (path, name, type) => {
    const { files } = get();
    const newFile: FileNode = {
      name,
      type,
      path: `${path}/${name}`,
      content: type === 'file' ? '' : undefined,
      children: type === 'directory' ? [] : undefined
    };

    // Add to parent directory or root
    const updatedFiles = [...files];
    if (path === '') {
      updatedFiles.push(newFile);
    } else {
      // Find parent and add to children
      const addToDirectory = (nodes: FileNode[], targetPath: string): boolean => {
        for (const node of nodes) {
          if (node.path === targetPath && node.type === 'directory') {
            node.children = node.children || [];
            node.children.push(newFile);
            return true;
          }
          if (node.children && addToDirectory(node.children, targetPath)) {
            return true;
          }
        }
        return false;
      };
      addToDirectory(updatedFiles, path);
    }

    set({ files: updatedFiles });
  },

  deleteFile: (path) => {
    const { files, openTabs } = get();
    
    const removeFromFiles = (nodes: FileNode[]): FileNode[] => {
      return nodes.filter(node => {
        if (node.path === path) return false;
        if (node.children) {
          node.children = removeFromFiles(node.children);
        }
        return true;
      });
    };

    const updatedFiles = removeFromFiles([...files]);
    const updatedTabs = openTabs.filter(tab => !tab.path.startsWith(path));

    set({
      files: updatedFiles,
      openTabs: updatedTabs,
      activeTab: updatedTabs.length > 0 ? updatedTabs[0].path : null
    });
  },

  renameFile: (oldPath, newPath) => {
    const { files, openTabs } = get();
    
    const updatePaths = (nodes: FileNode[]): FileNode[] => {
      return nodes.map(node => {
        if (node.path === oldPath) {
          return { ...node, path: newPath, name: newPath.split('/').pop() || newPath };
        }
        if (node.children) {
          node.children = updatePaths(node.children);
        }
        return node;
      });
    };

    const updatedFiles = updatePaths([...files]);
    const updatedTabs = openTabs.map(tab =>
      tab.path === oldPath ? { ...tab, path: newPath } : tab
    );

    set({
      files: updatedFiles,
      openTabs: updatedTabs
    });
  },

  markTabClean: (path) => {
    const { openTabs } = get();
    const updatedTabs = openTabs.map(tab =>
      tab.path === path ? { ...tab, isDirty: false } : tab
    );
    set({ openTabs: updatedTabs });
  }
}));